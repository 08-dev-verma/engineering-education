Let us create a mental scenario here. A patriot normally has an electricity meter installed in his house. Every second he uses power; usage data is sent periodically from the electricity meter to the Power Office. Consequently, two values detailing his amount of total power used and amount of power remaining are sent to this user on the smart phone installed on his phone. This is how power works in my country, Nigeria.

In this project, we will mimic an electricity meter that reads a user’s power usage on the one end. The user has a mobile installed and from the stream of data generated by his electricity meter and he has see his consumption rate, power remaining and total power used on the other end. This can be easily done using the Django F function. This approach is an extremely efficient approach.

### Table of contents
The tutorial will cover:

- [How is the F Function efficient?](#how-is-the-f-function-efficient?)
- [Implementing models for usage in demonstration](implementing-models-for-usage-in-demonstration)
- [How the F function works actually](#how-the-f-function-works-actually)
- [Points to note](#points-to-note)
- [Key Takeaways](#key-takeaways)
- [Conclusion](#conclusion)

### Prerequisites
To make the most of this tutorial, it is required to have:
- Basic understanding of Python.
- Familiarity with the Django framework and Django Rest framework.
- Familiarity with the Django rest framework browseable API interface.
- PyCharm professional code editor installed.

### How is F Function efficient?
The traditional approach would have been to constantly fetch and iterate over the stream of data – readings, get the sum of power used and subtract it from the threshold to get the values of power used and power remaining. This is a less efficient approach. With the F function, a single reading object (meant for the user) can be updated on the fly, without reference to the previous data, saved to the database and ready for the user to see. You can do this for multiple fields at a go.

### Implementing models for usage in demonstration
Our small demonstration of how F function works will require three models: `RegisterMeter`, `MeterReading` and `CurrentUsage`. The code snippets below show the models and serializers for creating these models.

```python
from django.db import models


class RegisterMeter(models.Model):
    meter_id = models.CharField(max_length=10)
    date_added = models.DateTimeField(auto_now=True)

    def __str__(self):
        return str(self.pk)


class MeterReading(models.Model):
    meter = models.CharField(max_length=10)
    meter_reading = models.IntegerField()
    date_sent = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.meter


class CurrentUsage(models.Model):
    meter = models.CharField(max_length=10)
    total_power_used = models.CharField(max_length=10)
    power_remaining = models.CharField(max_length=10)

    def __str__(self):
        return self.meter
```

```python
from rest_framework import serializers
from .models import MeterReading, CurrentUsage, RegisterMeter


class MeterReadingSerializer(serializers.ModelSerializer):
    class Meta:
        model = MeterReading
        fields = '__all__'


class CurrentUsageSerializer(serializers.ModelSerializer):
    class Meta:
        model = CurrentUsage
        fields = '__all__'


class RegisterMeterSerializer(serializers.ModelSerializer):
    class Meta:
        model = RegisterMeter
        fields = '__all__'
```

The `RegisterMeter` on-boards an electricity meter, `MeterReading` represents a single data body generated from the electricity meter and sent to the Power Office and the `CurrentUsage` is what reading the user sees displaying his power used and power remaining.
The idea is that, while onboarding an electricity meter, a default `CurrentUsage` is created, where the `total_power_used` and `power_remaining` are both zeores for the meter and on the creation of every `MeterReading` object, the `CurrentUsage` object is always updated. The `view` and `url` for onboarding a meter is shown below:

```python
class RegisterMeterCreateView(generics.CreateAPIView):
    queryset = RegisterMeter.objects.all()
    serializer_class = RegisterMeterSerializer

    def post(self, request, *args, **kwargs):
        serializer = self.get_serializer(data=request.data)
        if not serializer.is_valid(raise_exception=True):
            return Response({"message": "Something went wrong"}, status=status.HTTP_400_BAD_REQUEST)

        meter = request.data.get('meter_id')

        payload = {
            "meter": meter,
            "total_power_used": "0",
            "power_remaining": "0",
        }

        CurrentUsage.objects.create(**payload)

        if serializer.is_valid():
            serializer.save()

        return Response({"message": "Meter has been on-boarded and a default current reading created"},
                        status=status.HTTP_200_OK)
```

```python
from django.urls import path

from meter.views import RegisterMeterCreateView, check_meter_usage, CreateMeterReading, \
    AllMetersListView

urlpatterns = [
    path('add-meter', RegisterMeterCreateView.as_view()),
    path('all-meters', AllMetersListView.as_view()),
]
```

To view all meters that have been registered, the view is shown in the snippet below:

```python
class AllMetersListView(generics.ListAPIView):
    queryset = RegisterMeter.objects.all()
    serializer_class = RegisterMeterSerializer
```

As a result of the above, we also need to have a view and URL to check for a `CurrentUsage` object using the `meter`’s ID

```python
@api_view(['GET'])
def check_meter_usage(self, meter_id):
    meter_reading = CurrentUsageSerializer(CurrentUsage.objects.get(meter=meter_id))
    return Response(meter_reading.data)
```

```python
from django.urls import path

from meter.views import RegisterMeterCreateView, check_meter_usage, CreateMeterReading, \
    AllMetersListView

urlpatterns = [
    path('add-meter', RegisterMeterCreateView.as_view()),
    path('all-meters', AllMetersListView.as_view()),
    path('meter-usage/<str:meter_id>', check_meter_usage), #  New
```
The view and URL to create a single meter reading object are shown in the code snippet below:

```python
class CreateMeterReading(generics.CreateAPIView):   # New
    queryset = MeterReading.objects.all()
    serializer_class = MeterReadingSerializer

    def post(self, request, *args, **kwargs):
        serializer = self.get_serializer(data=request.data)
        if not serializer.is_valid(raise_exception=True):
            return Response({"message": "Something went wrong"}, status=status.HTTP_400_BAD_REQUEST)

        meter = request.data.get('meter')
        meter_reading = int(request.data.get('meter_reading'))

        meter_usage_object = CurrentUsage.objects.get(meter=meter)
        CurrentUsage.objects.filter(meter=meter_usage_object.meter).update(
            total_power_used=F("total_power_used") + meter_reading,
            power_remaining=25 - (F("total_power_used") + meter_reading)
        )

        meter_usage_object.refresh_from_db()

        if serializer.is_valid():
            serializer.save()
        return Response({"message": "Reading created, current usage updated"}, status=status.HTTP_200_OK)
```

```python

from django.urls import path

from meter.views import RegisterMeterCreateView, check_meter_usage, CreateMeterReading, \
    AllMetersListView

urlpatterns = [
    path('add-meter', RegisterMeterCreateView.as_view()),
    path('all-meters', AllMetersListView.as_view()),
    path('meter-usage/<str:meter_id>', check_meter_usage),
    path('create-reading', CreateMeterReading.as_view()),  # new
]
```
### How the F function works actually
Now, that we have our models, serializers, views and URL, let us begin the actual demonstration of the mini-project. We create/register a new meter using the endpoint `localhost:8000/add-meter` and fill in the page accordingly.
To check that the meter was successfully registered and a new `CurrentUsage` was created in the process, visit `localhost:8000/all-meters` and `localhost:8000/meter-usage/PM01`
![wecreatemeter](/engineering-education/runtime-update-of-multiple-fields-in-django-using-the-f-function-the-most-efficient-way-to-go/wecreatemeter.jpg)
![wecreatedmeter](/engineering-education/runtime-update-of-multiple-fields-in-django-using-the-f-function-the-most-efficient-way-to-go/wecreatedmeter.jpg)
![allmeterlist](/engineering-education/runtime-update-of-multiple-fields-in-django-using-the-f-function-the-most-efficient-way-to-go/allmeterlist.jpg)
![defmeterusage](/engineering-education/runtime-update-of-multiple-fields-in-django-using-the-f-function-the-most-efficient-way-to-go/defmeterusage.jpg)

Let us create a usage `MeterReading` for our meter (which is sent to the Power Office’s server) and update the meter’s `CurrentUsage` in the process.
![ createreadingnewview](/engineering-education/runtime-update-of-multiple-fields-in-django-using-the-f-function-the-most-efficient-way-to-go/createreadingnewview.jpg)
![create-reading-act](/engineering-education/runtime-update-of-multiple-fields-in-django-using-the-f-function-the-most-efficient-way-to-go/create-reading-act.jpg)
![create-reading-act1](/engineering-education/runtime-update-of-multiple-fields-in-django-using-the-f-function-the-most-efficient-way-to-go/create-reading-act1.jpg)
![create-reading-act2](/engineering-education/runtime-update-of-multiple-fields-in-django-using-the-f-function-the-most-efficient-way-to-go/create-reading-act2.jpg)

We see from above that a reading of 1 unit is sent from the meter and consequently, the current usage updated to reflect an expense from the `MeterReading`. Check the current usage with the endpoint `localhost:8000/meter-usage/PM01` and confirm that this happened. (We are assuming a usage threshold of 25 units, so when the meter read that he spent 1 unit, he had 24 left).
![create-reading-act3](/engineering-education/runtime-update-of-multiple-fields-in-django-using-the-f-function-the-most-efficient-way-to-go/ create-reading-act3.jpg)
Let’s try with a higher meter reading, say 3. We see that the `CurrentUsage` is updated again; power used becomes 4 and power remaining becomes 21.
![create-reading-act4](/engineering-education/runtime-update-of-multiple-fields-in-django-using-the-f-function-the-most-efficient-way-to-go/ create-reading-act4.jpg)
![create-reading-act5](/engineering-education/runtime-update-of-multiple-fields-in-django-using-the-f-function-the-most-efficient-way-to-go/ create-reading-act5.jpg)

### Key Takeaways
After following this tutorial, you have another insight as to manipulating the fields of a Django model without having to make too many calls and passing objects about. The F function does a lot of this heavy-lifting and you can manipulate as many fields as you might want to.

### Points to Note
You can use the F function to update a debt or loan repayment scheme for a user or build a gas-reading solution, at runtime and without having to deal with too many objects and tables. With this, one can make out a number of things. For instance, because each `MeterReading` is saved, the power usage history of any user can be fetched and supplied to him, for transparency or audit sakes.
At the point of updating the `CurrentUsage` – during the creation of each, validations and conditions can be set before the `MeterReading` is saved for any meter. The current usage can also be updated to represent a reset of the electricity meter. This can be achieved by sending in a negative number as the `power_used`, say `-1` and then saving zeroes in respective places against values for that meter.

### Conclusion
In this article, we have learnt why using the F function is better and how to use it. Efficiency matters in programming and it is best that we always seek out ways to improve the efficiency of our programmes. Using the F function in Python is certainly one of these ways
You can find the code pushed to Github on [link](https://github.com/teevyne/f-function)
Thank you and enjoy the rest of your life every single day.
